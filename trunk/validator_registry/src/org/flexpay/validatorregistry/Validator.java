package org.flexpay.validatorregistry;

import org.flexpay.validatorregistry.service.SignatureService;
import org.flexpay.validatorregistry.service.impl.RSASignatureService;
import org.flexpay.validatorregistry.util.ConfigUtil;
import org.flexpay.validatorregistry.util.TextAreaWriter;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.*;
import java.security.Signature;
import java.security.SignatureException;
import java.util.ResourceBundle;

public class Validator extends JDialog {

    private JPanel contentPane;
    private JPanel filePanl;
    private JTextField fileFld;
    private JButton selectBtn;
    private JLabel fileLbl;
    private JButton validateBtn;
    private JPanel consoleOutPnl;
    private JScrollPane consoleScrollPnl;
    private JTextArea consoleOutTxtArea;
    private JPanel topPnl;

    private SignatureService signatureService = new RSASignatureService();

    public Validator() {

        $$$setupUI$$$();

        PrintStream ps = new PrintStream(new TextAreaWriter(consoleOutTxtArea, Integer.valueOf(ConfigUtil.getConfigKey("dialog.maximum_console_history_lines"))));
        System.setOut(ps);
        System.setErr(ps);

        setContentPane(contentPane);
        setModal(true);
        setResizable(false);
        getRootPane().setDefaultButton(selectBtn);

        selectBtn.addActionListener(new ActionListener() {
            /**
             * Invoked when an action occurs.
             */
            public void actionPerformed(ActionEvent e) {
                JFileChooser fileChooser = new JFileChooser();
                fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
                String fileName = ConfigUtil.getConfigKey("dialog.default_registry_path");
                File file = new File(fileName);
                if (file.exists()) {
                    fileChooser.setSelectedFile(file);
                }

                int result = fileChooser.showOpenDialog(contentPane);
                if (result == JFileChooser.APPROVE_OPTION) {
                    File selectedFile = fileChooser.getSelectedFile();
                    fileFld.setText(selectedFile.getAbsolutePath());
                }
            }
        });

        validateBtn.addActionListener(new ActionListener() {
            /**
             * Invoked when an action occurs.
             */
            public void actionPerformed(ActionEvent e) {
                setEnabledControlElements(false);
                Thread thread = new Thread(new ValidateThread());
                thread.start();
            }
        });

    }

    /**
     * Disable or enable UI elements
     *
     * @param flag if flag = true then enable UI elements, disable if false
     */
    private void setEnabledControlElements(boolean flag) {
        selectBtn.setEnabled(flag);
        validateBtn.setEnabled(flag);
    }

    public static void main(String[] args) throws Exception {

        Validator dialog = new Validator();
        dialog.pack();
        dialog.setVisible(true);

        System.exit(0);

    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        contentPane = new JPanel();
        contentPane.setLayout(new BorderLayout(0, 0));
        contentPane.setMaximumSize(new Dimension(800, 214));
        contentPane.setMinimumSize(new Dimension(600, 86));
        contentPane.setOpaque(true);
        contentPane.setPreferredSize(new Dimension(700, 238));
        consoleOutPnl = new JPanel();
        consoleOutPnl.setLayout(new BorderLayout(0, 0));
        contentPane.add(consoleOutPnl, BorderLayout.SOUTH);
        consoleScrollPnl = new JScrollPane();
        consoleOutPnl.add(consoleScrollPnl, BorderLayout.CENTER);
        consoleOutTxtArea = new JTextArea();
        consoleOutTxtArea.setColumns(60);
        consoleOutTxtArea.setDragEnabled(false);
        consoleOutTxtArea.setEditable(true);
        consoleOutTxtArea.setRows(12);
        consoleScrollPnl.setViewportView(consoleOutTxtArea);
        topPnl = new JPanel();
        topPnl.setLayout(new BorderLayout(0, 0));
        contentPane.add(topPnl, BorderLayout.CENTER);
        filePanl = new JPanel();
        filePanl.setLayout(new GridBagLayout());
        topPnl.add(filePanl, BorderLayout.CENTER);
        fileLbl = new JLabel();
        fileLbl.setHorizontalAlignment(0);
        this.$$$loadLabelText$$$(fileLbl, ResourceBundle.getBundle("org/flexpay/validatorregistry/i18n/messages").getString("dialog.registry_file_path_label"));
        GridBagConstraints gbc;
        gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.weighty = 1.0;
        filePanl.add(fileLbl, gbc);
        fileFld = new JTextField();
        fileFld.setColumns(32);
        fileFld.setEditable(false);
        fileFld.setHorizontalAlignment(10);
        gbc = new GridBagConstraints();
        gbc.gridx = 1;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.weighty = 1.0;
        filePanl.add(fileFld, gbc);
        selectBtn = new JButton();
        selectBtn.setHorizontalTextPosition(0);
        this.$$$loadButtonText$$$(selectBtn, ResourceBundle.getBundle("org/flexpay/validatorregistry/i18n/messages").getString("dialog.button.select"));
        gbc = new GridBagConstraints();
        gbc.gridx = 2;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.weighty = 1.0;
        filePanl.add(selectBtn, gbc);
        validateBtn = new JButton();
        validateBtn.setEnabled(true);
        this.$$$loadButtonText$$$(validateBtn, ResourceBundle.getBundle("org/flexpay/validatorregistry/i18n/messages").getString("dialog.button.validate"));
        gbc = new GridBagConstraints();
        gbc.gridx = 3;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.weighty = 1.0;
        filePanl.add(validateBtn, gbc);
    }

    /**
     * @noinspection ALL
     */
    private void $$$loadLabelText$$$(JLabel component, String text) {
        StringBuffer result = new StringBuffer();
        boolean haveMnemonic = false;
        char mnemonic = '\0';
        int mnemonicIndex = -1;
        for (int i = 0; i < text.length(); i++) {
            if (text.charAt(i) == '&') {
                i++;
                if (i == text.length()) break;
                if (!haveMnemonic && text.charAt(i) != '&') {
                    haveMnemonic = true;
                    mnemonic = text.charAt(i);
                    mnemonicIndex = result.length();
                }
            }
            result.append(text.charAt(i));
        }
        component.setText(result.toString());
        if (haveMnemonic) {
            component.setDisplayedMnemonic(mnemonic);
            component.setDisplayedMnemonicIndex(mnemonicIndex);
        }
    }

    /**
     * @noinspection ALL
     */
    private void $$$loadButtonText$$$(AbstractButton component, String text) {
        StringBuffer result = new StringBuffer();
        boolean haveMnemonic = false;
        char mnemonic = '\0';
        int mnemonicIndex = -1;
        for (int i = 0; i < text.length(); i++) {
            if (text.charAt(i) == '&') {
                i++;
                if (i == text.length()) break;
                if (!haveMnemonic && text.charAt(i) != '&') {
                    haveMnemonic = true;
                    mnemonic = text.charAt(i);
                    mnemonicIndex = result.length();
                }
            }
            result.append(text.charAt(i));
        }
        component.setText(result.toString());
        if (haveMnemonic) {
            component.setMnemonic(mnemonic);
            component.setDisplayedMnemonicIndex(mnemonicIndex);
        }
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return contentPane;
    }

    public class ValidateThread implements Runnable {

        @Override
        public void run() {

            setEnabledControlElements(false);
            FileInputStream is = null;
            try {
                is = new FileInputStream(new File(fileFld.getText()));

                System.out.println("------------------------------------------");
                System.out.println("Start validating file " + fileFld.getText());

                if (assertDigitalSignature(is, ConfigUtil.getConfigKey("registry.file_key_path"))) {
                    System.out.println("Digital signature OK for file " + fileFld.getText());
                } else {
                    System.out.println("Digital signature FAILED for file " + fileFld.getText());
                }

                System.out.println("Finish validating file " + fileFld.getText());
                System.out.println("------------------------------------------");

            } catch (Exception e) {
                System.err.println("File with path " + fileFld.getText() + " not found");
                e.printStackTrace();
            } finally {
                if (is != null) {
                    try {
                        is.close();
                    } catch (IOException e) {
                        System.err.println("Can't close input stream");
                        e.printStackTrace();
                    }
                }
            }

            setEnabledControlElements(true);
            repaint();

        }

    }

    public boolean assertDigitalSignature(InputStream is, String key) throws Exception {

        System.out.println("Reading public key...");
        Signature sign = signatureService.readPublicSignature(key);
        System.out.println("Read public key OK");

        String configServiceLine = ConfigUtil.getConfigKey("registry.service_line");
        byte[] lineFeed = "\n".getBytes(ConfigUtil.getConfigKey("registry.file_encoding"));

        System.out.println("Reading service line...");
        String serviceLine = new String(Validator.read(is, configServiceLine.length()));
        if (!configServiceLine.equals(serviceLine)) {
            System.out.println("Incorrect service line:\n" + serviceLine);
            return false;
        }
        System.out.println("Read service line OK");

        Validator.read(is, lineFeed.length);

        // 128 - is a size of SHA-1 signature
        System.out.println("Reading signature...");
        byte[] signature = Validator.read(is, 128);
        System.out.println("Read signature OK");

        // skip service lines - up to a 3 new feed lines
        System.out.println("Skipping other service lines...");
        int nFeedsFound = 0;
        byte[] ringBuffer = new byte[lineFeed.length];
        while (nFeedsFound < 3) {
            ringBuffer[ringBuffer.length - 1] = (byte) is.read();
            if (equals(lineFeed, ringBuffer)) {
                ++nFeedsFound;
                ringBuffer = new byte[lineFeed.length];
                continue;
            }
            shiftLeft(ringBuffer);
        }
        System.out.println("Skip other service lines OK");

        System.out.println("Verifing digital signature...");

        try {
            byte[] buffer = new byte[1024];
            int nRead;
            while ((nRead = is.read(buffer)) != -1) {
                sign.update(buffer, 0, nRead);
            }
        } catch (SignatureException e) {
            System.err.println("Error with verifing signature");
            e.printStackTrace();
            throw new RuntimeException(e);
        }

        return sign.verify(signature);

    }

    private void shiftLeft(byte[] ar) {
        System.arraycopy(ar, 1, ar, 0, ar.length - 1);
    }

    private boolean equals(byte[] ar1, byte[] ar2) {
        if (ar1.length != ar2.length) {
            return false;
        }
        for (int i = 0; i < ar1.length; ++i) {
            if (ar1[i] != ar2[i]) {
                return false;
            }
        }
        return true;
    }


    public static byte[] read(InputStream is, int n) throws IOException {

        byte[] bytes = new byte[n];

        for (int i = 0; i < n; ++i) {
            bytes[i] = (byte) is.read();
        }
        return bytes;
    }

}
